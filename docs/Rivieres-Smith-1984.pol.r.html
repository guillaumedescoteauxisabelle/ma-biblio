<h1 id="the-implementation-of-procedurally-reflective-languages">The implementation of procedurally reflective languages</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://zotero.org/users/180474/items/WDNR8CQI">ZotWeb</a></td>
<td>paper-conference</td>
<td></td>
</tr>
<tr>
<td><a href="http://doi.org/10.1145/800055.802050">Src Url</a></td>
<td>[[Rivi√®res]], [[Smith]] (1984)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="abstract">Abstract</h2>
<p>In a procedurally reflective programming language, all programs are executed not through the agency of a primitive and inaccessible interpreter, but rather by the explicit running of a program that represents that interpreter. In the corresponding virtual machine, therefore, there are an infinite number of levels at which programs are processed, all simultaneously active. It is therefore a substantial question to show whether, and why, a reflective language is computationally tractable. We answer this question by showing how to produce an efficient implementation of a procedurally reflective language, based on the notion of a level-shifting processor. A series of general techniques, which should be applicable to reflective variants of any standard applicative or imperative programming languages, are illustrated in a complete implementation for a particular reflective LISP dialect called 3-LISP.</p>
<hr>
<h2 id="annotations">Annotations</h2>
<p>Rivieres</p>
<hr>
<hr>
